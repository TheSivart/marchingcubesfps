<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>-5</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///ADD TO GMnet ENGINE
/**
  * Starts syncing.
  * Everything in this script MUST only be run in the create event and at the very beginning.
  */
mp_sync();
/**
 * Tell the engine to add the position:
 * x,y
 * These variables will be synced as part of a so called "variable group".
 * It will be called "Pos" and syncs it every 5 seconds.
 * We sync the position every 5 seconds to prevent the players from desyncing.
 */
mp_addPosition("Pos",1*room_speed);
mp_add("Vars","z",buffer_s16,1*room_speed);
/**
  * Change the sync mode to be SMART.
  * This means that the packets get definitely delivered, this "emulates" the 
  * reliability of TCP.
  * And it also only syncs if the variable has changed since the last sync.
  * Please note that this is not that fast and should not be executed for the same group
  * in a short time, so set a big delay!
  */
mp_setType("Pos",mp_type.SMART);
mp_setType("Vars",mp_type.SMART);
/**
  * Adds a tolerance of 20 to the Pos group (x and y position).
  * This meand when a client recieves the position update, it will only sync it, if the
  * local x and y position are 20 pixels more/less than the actual position.
  * Since we sync the position to avoid desync, a low number means the player might "flicker" every
  * time the position is recieved, because it slightly changes it.
  * We only want to change it if the client is significantly away from the player, so it get's 
  * corrected.
  */
mp_tolerance("Pos",2);
mp_tolerance("Vars",2);


/**
 * Tell the engine to add the basic drawing variables:
 * image_alpha,image_angle,image_blend,image_index,image_speed,image_xscale
 * image_yscale,visible
 * This is mostly to sync the xscale (the direction the player faces in) and the color in this demo.
 * Also synced for the same reason as the position: To avoid desync.
 */
mp_addBuiltinBasic("basicDrawing",15*room_speed);
mp_setType("basicDrawing",mp_type.SMART);

/**
 * Tell the engine to add the builtin GameMaker variables:
 * direction,gravity,gravity_direction,friction,hspeed,vspeed
 * Sync the entire physics. Also to avoid desync.
 */
mp_addBuiltinPhysics("basicPhysics",1);
mp_setType("basicPhysics",mp_type.SMART);

/**
 * This adds two custom groups that sync the variables 
 * name,pressed_jump,pressed_left,pressed_right
 *
 * SADLY, due to current limitations in GML, we can't access any of this variables by their
 * name in the engine. You need to add their values to a special list in begin step and
 * retrieve them in end step. Go to these events in this demo object and you'll see.
 *
 * Name is synced to update the name (obviously) and is sent SMART and with great delay between the
 * syncs, since it shouldn't actually sync at all. At this point we should note, that all variable
 * groups also get synced automatically when needed, for example if someone connects or changes room.
 *
 * The second group syncs the controls every step, this is the important part, this is what actually
 * moves the player.
 *
 * Since no type was changed, the default type FAST is chosen, this means packets get sent
 * only once, but very fast.
 * This however means, that the other clients could desync, that's why we sync position and physics.
 *
 * The third argument specifys the type of the variables. See
 * http://docs.yoyogames.com/source/dadiospice/002_reference/buffers/buffer_read.html
 * for all options
 */
mp_add("bomb","bomb_type,bomb_x,bomb_y,bomb_z,bomb_count",buffer_u8,1);
mp_add("playerName","name",buffer_string,60*room_speed);
mp_setType("playerName",mp_type.SMART);
mp_add("controls","pr_w,pr_s,pr_a,pr_d,pr_space",buffer_bool,1);



/** 
 * By the way:
 * Our object player is persistent. That means it will travel through rooms without getting destroyed.
 * Non local players however WILL get destroyed on changing the room.
 * This way, when entering a room, only our player will actually travel.
 * If you also want to sync non local players between rooms, see object obj_htme_time
 */
</string>
          </argument>
        </arguments>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Setup basic stuff for the demo platformer.

/** These variables are used to indicate if the player hat controls this
  * player instance, has pressed one of the three buttons.
  */
self.pr_w = false;
self.pr_s = false;
self.pr_a = false;
self.pr_d = false;
self.pr_space = false;
self.name = "";
self.z = 220;
self.bomb_type=0;
self.bomb_x=0;
self.bomb_y=0;
self.bomb_z=0;
self.bomb_count=0;
bomb_count2 = 0;

xto=0;
yto=0;
zto=0;

z_grav = 0;

/** 
  * Check if this instance is created by the local player.
  * If yes, set up color and name.
  * You should always check if you are changing the local player, because
  * in this case we want color and name to come from the other players.
  *
  * All these helpful tool scripts can be found in scripts-&gt;htme-&gt;tools
  * See the chat or playerlist objects for more examples.
  */
if (htme_isLocal()) {
    /** Totro generates random names and is not part of the main engine, it's
      * another marketplace asset by me :)
      */
    var ttr = "player"+string(random(100));
    self.name = ttr;
    /** Gives this player a random color. */
    self.image_blend = irandom(16777215);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///RETRIEVE VARIABLES FROM THE ENGINE
/** SADLY, due to current limitations in GML, we need to add all variables added to the
  * engine by using mp_add (mp_addBuiltin* are not needed to be added here!!).
  * Just use this as a template and copy it.
  *
  * More information in Begin Step. This here does the oposite, it sets the instance variables
  * to the variables stored in the engine.
  **/

self.name = mp_map_syncOut("name", self.name);
self.pr_w = mp_map_syncOut("pr_w", self.pr_w);
self.pr_s = mp_map_syncOut("pr_s", self.pr_s);
self.pr_a = mp_map_syncOut("pr_a", self.pr_a);
self.pr_d = mp_map_syncOut("pr_d", self.pr_d);
self.pr_space = mp_map_syncOut("pr_space", self.pr_space);
self.z = mp_map_syncOut("z", self.z);
self.bomb_type = mp_map_syncOut("bomb_type", self.bomb_type);
self.bomb_x = mp_map_syncOut("bomb_x", self.bomb_x)*10;
self.bomb_y = mp_map_syncOut("bomb_y", self.bomb_y)*10;
self.bomb_z = mp_map_syncOut("bomb_z", self.bomb_z)*10;
self.bomb_count = mp_map_syncOut("bomb_count", self.bomb_count);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>if (htme_isLocal()) {
    self.pr_w = keyboard_check(ord("W"));
    self.pr_s = keyboard_check(ord("S"));
    self.pr_a = keyboard_check(ord("A"));
    self.pr_d = keyboard_check(ord("D"));
    self.pr_space = keyboard_check(vk_space);
}
if (obj_control.chunk_loading==false)
{
    var zto=z;
    z_grav -= 0.2;
    zto+=z_grav;
    if (scr_col_pos(x,y,zto)==false){z=zto;}else{z_grav=0;}
}
with(obj_bomb)
{
    if (mode==0)
    {
        repeat(10)
        {
            x+=xsp*2;
            y+=ysp*2;
            z+=zsp*2;
            
            if (scr_col_pos_single(x,y,z)==true)
            {
                other.bomb_type = type;
                other.bomb_x = x;
                other.bomb_y = y;
                other.bomb_z = z;
                other.bomb_count += 1;
                instance_destroy();
            }
        }
    }
}
/** THIS SYNCS THE VARIABLES WITH THE ENGINE
  * Add every variable synced via mp_add here!
  * DO NOT JUST DO THIS FOR THE LOCAL PLAYER! Do it for all!
  */
mp_map_syncIn("name",self.name);
mp_map_syncIn("pr_w",self.pr_w);
mp_map_syncIn("pr_s",self.pr_s);
mp_map_syncIn("pr_a",self.pr_a);
mp_map_syncIn("pr_d",self.pr_d);
mp_map_syncIn("pr_space",self.pr_space);
mp_map_syncIn("z",self.z);
mp_map_syncIn("bomb_type",self.bomb_type);
mp_map_syncIn("bomb_x",round(self.bomb_x/10));
mp_map_syncIn("bomb_y",round(self.bomb_y/10));
mp_map_syncIn("bomb_z",round(self.bomb_z/10));
mp_map_syncIn("bomb_count",self.bomb_count);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>///Move
if (obj_control.chunk_loading==false)
{
    if (htme_isLocal()) 
    {
        direction=obj_control.direction;
    }
    if(self.bomb_count&gt;bomb_count2)
    {
        switch(bomb_type)
        {
            case 1:
                scr_ex(bomb_x,bomb_y,bomb_z);
                var obj=instance_create(bomb_x,bomb_y,obj_ex);
                obj.z=bomb_z;obj.type=bomb_type;
            break;
            case 2:
                scr_ex2(bomb_x,bomb_y,bomb_z);
                var obj=instance_create(bomb_x,bomb_y,obj_ex);
                obj.z=bomb_z;obj.type=bomb_type;
            break;
        }
        bomb_count2 += 1;
    }
    //if (scr_col_pos(xto,yto,z-0.5)==false){z-=0.5}
    var sp=1,xto=x,yto=y,zto=z;
    if (self.pr_w)
    {
        xto+=lengthdir_x(sp,direction);
        yto+=lengthdir_y(sp,direction);
    }
    if (self.pr_s)
    {
        xto+=lengthdir_x(sp,direction+180);
        yto+=lengthdir_y(sp,direction+180);
    }
    if (self.pr_a)
    {
        xto+=lengthdir_x(sp,direction+90);
        yto+=lengthdir_y(sp,direction+90);
    }
    if (self.pr_d)
    {
        xto+=lengthdir_x(sp,direction-90);
        yto+=lengthdir_y(sp,direction-90);
    }
    if (self.pr_space)
    {
        if (scr_col_pos(x,y,z-2)==true)
        {
            z_grav = 4;
        }
    }
    
    if (scr_col_pos(xto,y,z)==false){x=xto;}
    if (scr_col_pos(x,yto,z)==false){y=yto;}
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints>
    <point>0,0</point>
    <point>16,16</point>
  </PhysicsShapePoints>
</object>
